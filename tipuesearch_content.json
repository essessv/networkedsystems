{"pages":[{"text":"I am an engineer interested in all aspects of networked systems - computer networks (incl. software-defined-networks, network virtualization) and distributed systems. Of particular interest is their application in cloud computing and scalable web backend architectures. This blog is an attempt to put my understanding into words, as I try to delve deeper into the internals of these complex networked systems. I have also been a big fan of Werner Vogel's blog , especially his Back-to-Basics Weekend Reading series. Check it out when you have the time. A section of this blog will be based on that idea. At least once every two weeks, I will pick one of the seminal published research papers that has had a high impact in the area of (distributed systems|computer networking|operating systems|storage), and will publish a writeup based upon my understanding.","tags":"pages","loc":"http://networkedsystems.net/about","title":"About"},{"text":"In no particular order, All Things Distributed High Scalability AOSA Michael Nielsen's Blog Papers We Love Eli Bendersky's Blog AWS Architecture Blog Gustavo Duarte IP Space Ethereal Mind Network Static Forwarding Plane Keeping It Classless","tags":"pages","loc":"http://networkedsystems.net/blogroll","title":"Blogroll"},{"text":"Computer Networking The design philosophy of the DARPA Internet protocols D. Clark. In Symposium proceedings on Communications architectures and protocols ( SIGCOMM ‘88), ACM , New York, NY , USA , 1988. < Paper > < My Review > End-to-end arguments in system design J. H. Saltzer, D. P. Reed, and D. D. Clark. In ACM Transactions on Computer Systems, 1984. < Paper > < My Review >","tags":"pages","loc":"http://networkedsystems.net/reading-list","title":"Reading List"},{"text":"The paper by Saltzer, Reed and Clark talks about the importance of moving functionality away from the lower layers of a networked system and placing them higher up the stack and closer to the applications, i.e., on the end-systems. The paper argues, with examples, that the end-to-end principle is the best approach for the design of networked systems. Two issues seen in systems where the lower layers implement some of the functionality are: The variety of possible application requirements means there will be some applications whose requirements aren't satisfied by the communication system. Such systems will choose to implement the functionality higher up the stack anyway. Some of the functionality might be duplicated. Introducing functionality into the lower layers of the stack introduces a kind of rigidity into the system. Applications that may not require the additional functionality cannot choose to opt out and that may result in certain performance implications for the application. The authors use various examples to support their argument of moving the functionality away from the network and onto the end-systems: Reliable File Transfer - there could be a host of problems that may occur when transferring a file from a host A to host B - from disk errors, to network transmission errors to glitches in the gateways themselves. Implementing reliability features such as retry mechanisms, error checks, sequencing, etc., in the lower layers of the network stack will only reduce the probability of the network being the problem. However, the end-systems still have to implement application-specific (file transfer, in this example) reliability mechanisms. Another caveat is the performance impact of having these reliability mechanisms in the network itself. Delivery Guarantees - it does not make sense for a communications network to acknowledge delivery of data to a destination host. This can be a very application specific acknowledgement, for example, for cases where a message results in an acknowledgement only once the message has been processed by the target application. Such cases are out of purview of the communications network. Secure transmission of data - the application should implement an end-to-end encryption, and perform key management. Relegating this responsibility to the network makes the data vulnerable en route to the target application. Duplicate message transmission Guaranteeing FIFO message delivery Transaction management The end-to-end system design of the Internet is the reason why it has been successful today. Operating systems on the end-hosts implement abstractions which developers can use to interface with the network stack, with functionality like reliability, etc., implemented in the upper layers ( TCP ). The design reduces the amount of functionality implemented at the lower layers - IP provides a best-effort service and is deemed to be an unreliable protocol (packet corruptions, loss, out-of-order and duplicate packets) with minimal amount of error checking by way of checksums. In conclusion, the end-to-end argument is a guideline to follow when designing networked systems. As stated in the paper, ..the end-to-end argument is not an absolute rule, but rather a guideline that helps in application and protocol design analysis; one must use some care to identify the end points to which the argument should be applied. Using the end-to-end argument sometimes requires subtlety of analyis of application requirements. References: End-to-end arguments in system design J. H. Saltzer, D. P. Reed, and D. D. Clark. In ACM Transactions on Computer Systems, 1984.","tags":"back-to-basics","loc":"http://networkedsystems.net/posts/2014/b2b-end2end-arguments-reed/","title":"Back-to-Basics: End-to-End Arguments in System Design"},{"text":"I've always been intrigued by the technologies that have had their start as research projects funded by DARPA . The Internet, in my opinion, is one project that has touched more lives than any other DARPA initiative. I first read this paper as part of my graduate course in computer networking, and it feels good to start right from the paper that got me interested in the area of networked systems. This paper is by David Clark and is one of the seminal papers in computer networking. It discussed about some of the core principles/motivations behind the design of the Internet protocols/architecture. The primary goal of the DARPA Internet initiative was to connect existing heterogeneous administratively separate networks together to form a larger network for the purposes of resource sharing, ease administration, etcetera. The underlying multiplexing mechanism for network resource sharing used was packet-switching since that was proven to be more robust and resilient to failures in ARPANET . Moreover, store-and-forward packet forwarding mechansim implemented in packet processors was chosen for similar reasons. The fundamental goal was further sub-divided into a prioritised list of requirements. In order of priority, Internet communication must continue despite loss of networks or gateways The Internet must support multiple types of communications service. The Internet architecture must accommodate a variety of networks. The Internet architecture must permit distributed management of its resources. The Internet architecture must be cost effective. The Internet architecture must permit host attachment with a low level of effort. The resources used in the internet architecture must be accountable. The military applications of the network meant that the items at the top of the list received more attention - one would want a communications network able to tolerate hostile enemy fire and able to sustain loss to parts of the network versus a network where resources accountability or cost effectiveness was of major importance. The seven items in the list can be categorized into three broad areas: Reliability (1) Flexibility (2, 3, 4, 6) Cost Efficiency and Accountability (5, 7) Reliability was achieved by a combination of packet-switched networking, and a design that resulted in a layered network protocol stack. In 1964, Paul Baran had proved the reliability of packet-switched networking when subject to network failures in his published paper, \" On Distributed Communications Networks .\" Layering of protocols meant that the lower layers stored as little information about the state of packet connections as possible, and instead, relegated that responsibility to upper layers which terminated in application on the end-hosts. This resulted in an architecture where the network was comprised of simple, stateless devices devoid of responsibility of ensuring reliable packet delivery, and instead pushed the responsibility of state management, retransmissions on failures etc. to upper-layer protocols and applications on the end-hosts. Clark called this fate-sharing . Moreover, this layered approach with the datagram being the fundamental building block meant that the network could support multiple types of transport services with application specific requirements. The result is a global scalable decentralized network capable of connecting millions of systems and transporting data. Today, it is impossible to imagine communication, business, education and entertainment without the Internet, and is widely treated to be just another utility service. References: The Design Philosophy of the DARPA Internet Protocols D. Clark. In Symposium proceedings on Communications architectures and protocols ( SIGCOMM ‘88), ACM , New York, NY , USA , 1988. On Distributed Communications Networks P. Baran, Communications Systems, IEEE Transactions on In Communications Systems, IEEE transactions on, Vol. 12, No. 1. pp. 1-9, March 1964.","tags":"back-to-basics","loc":"http://networkedsystems.net/posts/2014/b2b-darpa-design-policy-clark/","title":"Back-to-Basics: The design philosophy of the DARPA Internet protocols"},{"text":"Open vSwitch ( OVS ) has become the de facto software virtual switch in cloud computing deployments where multi-tenancy is a primary requirement. From the website, OVS is a production quality, multilayer virtual switch designed to enable massive network automation through programmatic extension, while still supporting standard management interfaces and protocols. The complete feature list can be found here . In this post, we will walk through the steps necessary to build OVS RPMs for Oracle's Unbreakable Enterprise Kernel v6. Environment I will be using the following OL6 Kernel and OVS version 2.1.2: 1 2 3 4 5 bash-4.1# uname -r 2.6.39-400.109.4.el6uek.x86_64 bash-4.1# ls openvswitch* openvswitch-2.1.2.tar.gz Build OVS RPMs Get the OL6 yum configuration file from Oracle's public yum server. 1 2 bash-4.1# cd /etc/yum.repos.d bash-4.1# wget http://public-yum.oracle.com/public-yum-ol6.repo Edit the public-yum-ol6.repo configuration file to enable the OL6_UEK_latest repository. 1 2 3 4 5 6 [ol6_UEK_latest] name=Latest Unbreakable Enterprise Kernel for Oracle Linux $releasever ($basearch) baseurl=http://public-yum.oracle.com/repo/OracleLinux/OL6/UEK/latest/$basearch/ gpgkey=file:///etc/pki/rpm-gpg/RPM-GPG-KEY-oracle gpgcheck=1 enabled=1 Update yum and install the packages listed below. 1 2 3 4 bash-4.1# yum update bash-4.1# yum install -y autoconf automake gcc libtool rpm-build bash-4.1# yum install -y openssl-devel python-devel kernel-uek-debug-devel bash-4.1# yum install -y kernel-uek-devel redhat-rpm-config kabi-whitelists OL6 has a broken build symbolic link. A ls command on /lib/modules/`uname -r`/build/ should result in a directory listing from /usr/src/kernel/`uname -r` . On OL6 , it results in a \"No such file or directory\" error. We need to fix this. 1 2 bash-4.1# rm /lib/modules/ ` uname -r ` /build bash-4.1# ln -s /usr/src/kernels/ ` uname -r ` /lib/modules/ ` uname -r ` /build Create the RPM building environment, 1 bash-4.1# mkdir -p ~/rpmbuild/ { SOURCES,RPMS,BUILD,SPECS,SRPMS } Copy over the Open vSwitch source tar.gz file to the RPM SOURCES directory, and untar it. Copy the openvswitch-kmod.files file to the RPM SOURCES directory as well. 1 2 3 bash-4.1# cp ~/openvswitch-2.1.2.tar.gz ~/rpmbuild/SOURCES bash-4.1# cd ~/rpmbuild/SOURCES; tar -xzf openvswitch-2.1.2.tar.gz bash-4.1# cp openvswitch-2.1.2/rhel/openvswitch-kmod.files ./ Next, build userspace component of OVS 1 2 bash-4.1# cd openvswitch-2.1.2 bash-4.1# rpmbuild -bb rhel/openvswitch.spec Build the OVS kernel module 1 bash-4.1# rpmbuild -bb -D \"kversion `uname -r`\" -D \"kflavors default debug\" rhel/openvswitch-kmod-rhel6.spec This results in the following four RPMs: 1 2 bash-4.1# ls ~/rpmbuild/RPMS/x86_64/ kmod-openvswitch-2.1.2-1.el6.x86_64.rpm kmod-openvswitch-debug-2.1.2-1.el6.x86_64.rpm openvswitch-2.1.2-1.x86_64.rpm openvswitch-debuginfo-2.1.2-1.x86_64.rpm kmod-* are the OVS kernel module RPMs and openvswitch-* are the RPMs for the userspace component of OVS . As is evident, this guide is very specific to Oracle's UEKv6. In a future post, I will be talking more about the features and capabilities that OVS provides. I will also show how OVS can be used to create multi-tenant virtual network overlays using VXLAN / GRE tunnels.","tags":"guide","loc":"http://networkedsystems.net/posts/2014/ovs-uek-build-install/","title":"Building Open vSwitch RPMs for Oracle Unbreakable Enterprise Linux 6"}]}